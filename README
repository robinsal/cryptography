The overall learning objective of this lab is to get familiar with
the concepts on substitution ciphers and symmetric key and public
key cryptography. You will be getting first-hand experience with
using the OpenSSL commandline tool and library to encrypt/decrypt
messages under different encryption modes, and to construct message
digests with hash functions. The tasks are set up in such a way
that you not only gain experience with the use of these various
mechanisms, but also with their properties. You are encouraged to
think about what these tools are doing, and why you get the results
you get. Some tasks ask you to write up these observations. You
will be using the same VM that you used for the previous projects.
Also, you will have to read up on the OpenSSL documentation.

Task 1: Cracking the Vigenere cipher

   In class, we only considered the Vigenere Cipher as a generalization
   of the Caesar Cipher. However, as described by Vigenere it can
   be used as a polyalphabetic Caesar-type Cipher. This employs a
   keyword, each letter of which is the shift for successive
   characters of the message.  That is, if we have "abc" as the
   keyword, then the first character of the ciphertext would be the
   first letter of the plaintext plus 0 (the value of "a"), the
   second would be plaintext plus 1, the third would be plaintext
   plus 2, and then the pattern would repeat with the fourth
   character. You can view this as a three-byte block cipher in ECB
   mode, if that helps. Section 5.2.1 of _Security Engineering_ goes
   into detail.

   As we saw with the repeated XOR in class, we can apply frequency
   analysis to individual characters (and even n-grams) encrypted
   with the same substitution. What we need to know is how long the
   keyword is, in order to know which characters are enciphered
   with the same substitution. Anderson discusses this briefly in
   the book, but you might find the Wikipedia page
   https://en.wikipedia.org/wiki/Index_of_coincidence useful as an
   additional reference. You may also find the library's page within
   the OpenSSL Wiki hekpful: https://wiki.openssl.org/index.php/EVP

   Your target ciphertext is contained in cipher1.txt

   You should develop tools (in the language of your choice) to
   perform the Index of Coincidence computation, frequency analysis
   (see crypto-exercises for n-gram frequencies for English), and
   decryption. Your submission should consist of:

      - keyword1.txt, which should include the keyword that you
                      determined

      - message1.txt, which should include the plaintext corresponding
                      to cipher1.txt

      - files.txt, which should include a list of all the program
		   files you used, any build instructions, and
		   instructions for calling the program or programs

   As a recommendation, you might consider using keyword1.txt and
   cipher1.txt as inputs to your decryption program, which would
   then produce message1.txt.

Task 2: Use OpenSSL for encryption

   OpenSSL (https://www.openssl.org/) is one of the most popular
   packages (at least in C) for performing cryptographic operations.
   It has implementations of all the major cryptosystems, including
   AES, which is what we will be using in this task. It has an API
   that allows it to be used in programs requiring cryptography,
   as well as a number of command-line utilities. The VM has the
   OpenSSL man pages installed, which provide the detailed usage
   information, use "man -k <keyword>" to find relevant page names.
   Additional documentation can be found at https://www.openssl.org/docs/

   AES takes a 256-bit (32-byte) key, and a 128-bit (16-byte) IV.
   You will use your student ID, right-padded with 0's, as the key
   (NOT a password), and a string of 16 0's as the IV. That is, if
   your UID is 123456789, then the key string would be
   "12345678900000000000000000000000" and the IV "0000000000000000".

   As discussed in class, if you want to encrypt more than a single
   block's worth of data, you need to select a streaming mode of
   operation. We will employ CBC (Cipher Block Chain), which will
   automatically pad the input with enough bytes to fill the last
   block.

   The file message2.txt contains a large plaintext to encrypt.

   Using the OpenSSL package in C, encrypt the contents of message2.txt
   with AES-256 given the key and IV as specified. This ciphertext
   should be written to a binary file named cipher2.out, though you
   do not need to read this back in, unless you want to.  Then, use
   SHA256 to hash this ciphertext to a short string, also in C,
   which should be output as hexadecimal, not raw binary.  You
   should have a single file, called encrypt2.c, that compiles
   to a program using OpenSSL and takes a filename as input. Your
   submission for this task should include:

      - encrypt2.c, containing your C code for encrypting and
                    hashing message2.txt
      - cipher2.out, containing the ciphertext produced using AES-256
		     in CBC mode
      - hash2.txt, containing the SHA256 hash of the AES-256
                   ciphertext

   To help you out, we've provided files sample2.in, sample2.cipher,
   and sample2.hash. These use the UID "123456789", so you can
   verify that your code is working correctly.  Obviously, you'll
   need to change the UID in your code to match this when testing,
   and to your UID for the submission.

   Please note:  Your submission must be written *entirely* in C
   (excluding the Makefile).  You may *not* use the OpenSSL
   command-line utilities to implement your submission, including
   by calling them using system() or exec().


